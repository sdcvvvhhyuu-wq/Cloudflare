<!DOCTYPE html>  
<html lang="en">  
<head>  
  <meta charset="UTF-8">  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <title>QR Code Manager Enterprise Edition</title>  
  <style>  
    * { margin: 0; padding: 0; box-sizing: border-box; }  
      
    body {  
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;  
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #7e22ce 100%);  
      min-height: 100vh;  
      display: flex;  
      align-items: center;  
      justify-content: center;  
      padding: 20px;  
    }  
      
    #qr-widget {  
      max-width: 600px;  
      width: 100%;  
      background: rgba(255, 255, 255, 0.95);  
      backdrop-filter: blur(10px);  
      border-radius: 20px;  
      padding: 30px;  
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);  
    }  
      
    .header {  
      text-align: center;  
      margin-bottom: 25px;  
    }  
      
    .header h1 {  
      font-size: 24px;  
      color: #1e293b;  
      margin-bottom: 8px;  
      font-weight: 700;  
    }  
      
    .header .subtitle {  
      font-size: 13px;  
      color: #64748b;  
      font-weight: 500;  
    }  
      
    .status-badge {  
      display: inline-block;  
      padding: 4px 12px;  
      border-radius: 12px;  
      font-size: 11px;  
      font-weight: 600;  
      margin-top: 8px;  
    }  
      
    .status-badge.ready { background: #dcfce7; color: #166534; }  
    .status-badge.processing { background: #fef3c7; color: #92400e; }  
    .status-badge.success { background: #dcfce7; color: #166534; }  
    .status-badge.error { background: #fee2e2; color: #991b1b; }  
      
    #qr-display {  
      min-height: 380px;  
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);  
      border-radius: 16px;  
      display: flex;  
      align-items: center;  
      justify-content: center;  
      position: relative;  
      overflow: hidden;  
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);  
      transition: all 0.3s ease;  
    }  
      
    #qr-display.generated {  
      background: transparent;  
    }  
      
    .qr-placeholder {  
      text-align: center;  
      color: #fff;  
      padding: 40px;  
    }  
      
    .qr-placeholder .icon {  
      font-size: 64px;  
      margin-bottom: 16px;  
      animation: float 3s ease-in-out infinite;  
    }  
      
    @keyframes float {  
      0%, 100% { transform: translateY(0px); }  
      50% { transform: translateY(-10px); }  
    }  
      
    .qr-placeholder .text {  
      font-size: 18px;  
      font-weight: 500;  
      opacity: 0.95;  
    }  
      
    #qr-info-panel {  
      margin-top: 16px;  
      padding: 16px;  
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);  
      border-radius: 12px;  
      display: none;  
      animation: slideIn 0.3s ease;  
    }  
      
    @keyframes slideIn {  
      from { opacity: 0; transform: translateY(-10px); }  
      to { opacity: 1; transform: translateY(0); }  
    }  
      
    .info-row {  
      display: flex;  
      justify-content: space-between;  
      align-items: center;  
      padding: 8px 0;  
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);  
    }  
      
    .info-row:last-child { border-bottom: none; }  
      
    .info-label {  
      font-size: 12px;  
      color: #64748b;  
      font-weight: 600;  
      text-transform: uppercase;  
      letter-spacing: 0.5px;  
    }  
      
    .info-value {  
      font-size: 13px;  
      color: #1e293b;  
      font-weight: 600;  
      font-family: 'Courier New', monospace;  
    }  
      
    .optimization-badge {  
      display: inline-block;  
      padding: 2px 8px;  
      border-radius: 8px;  
      font-size: 10px;  
      font-weight: 700;  
      margin-left: 8px;  
    }  
      
    .optimization-badge.high { background: #dcfce7; color: #166534; }  
    .optimization-badge.medium { background: #fef3c7; color: #92400e; }  
    .optimization-badge.low { background: #fee2e2; color: #991b1b; }  
      
    #qr-controls {  
      margin-top: 20px;  
      display: grid;  
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));  
      gap: 10px;  
    }  
      
    .btn {  
      padding: 12px 20px;  
      border: none;  
      border-radius: 10px;  
      font-size: 14px;  
      font-weight: 600;  
      cursor: pointer;  
      transition: all 0.2s ease;  
      display: flex;  
      align-items: center;  
      justify-content: center;  
      gap: 8px;  
      position: relative;  
      overflow: hidden;  
    }  
      
    .btn::before {  
      content: '';  
      position: absolute;  
      top: 50%;  
      left: 50%;  
      width: 0;  
      height: 0;  
      border-radius: 50%;  
      background: rgba(255, 255, 255, 0.3);  
      transform: translate(-50%, -50%);  
      transition: width 0.6s, height 0.6s;  
    }  
      
    .btn:hover::before {  
      width: 300px;  
      height: 300px;  
    }  
      
    .btn span { position: relative; z-index: 1; }  
      
    .btn:hover {  
      transform: translateY(-2px);  
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);  
    }  
      
    .btn:active {  
      transform: translateY(0);  
    }  
      
    .btn.primary { background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: #fff; }  
    .btn.secondary { background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: #fff; }  
    .btn.accent { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: #fff; }  
    .btn.special { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: #fff; }  
      
    #qr-message {  
      margin-top: 16px;  
      padding: 12px 16px;  
      border-radius: 10px;  
      font-size: 13px;  
      font-weight: 500;  
      text-align: center;  
      display: none;  
      animation: slideIn 0.3s ease;  
    }  
      
    #qr-message.show { display: block; }  
      
    #qr-message.info {  
      background: #dbeafe;  
      color: #1e40af;  
      border-left: 4px solid #3b82f6;  
    }  
      
    #qr-message.success {  
      background: #dcfce7;  
      color: #166534;  
      border-left: 4px solid #10b981;  
    }  
      
    #qr-message.warning {  
      background: #fef3c7;  
      color: #92400e;  
      border-left: 4px solid #f59e0b;  
    }  
      
    #qr-message.error {  
      background: #fee2e2;  
      color: #991b1b;  
      border-left: 4px solid #ef4444;  
    }  
      
    .progress-bar {  
      height: 4px;  
      background: rgba(0, 0, 0, 0.1);  
      border-radius: 2px;  
      margin-top: 12px;  
      overflow: hidden;  
      display: none;  
    }  
      
    .progress-bar.active { display: block; }  
      
    .progress-fill {  
      height: 100%;  
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);  
      width: 0%;  
      transition: width 0.3s ease;  
      animation: shimmer 1.5s infinite;  
    }  
      
    @keyframes shimmer {  
      0% { background-position: -200% 0; }  
      100% { background-position: 200% 0; }  
    }  
      
    .analytics-panel {  
      margin-top: 20px;  
      padding: 16px;  
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);  
      border-radius: 12px;  
      display: none;  
    }  
      
    .analytics-panel.show { display: block; }  
      
    .analytics-title {  
      font-size: 12px;  
      font-weight: 700;  
      color: #92400e;  
      text-transform: uppercase;  
      letter-spacing: 0.5px;  
      margin-bottom: 12px;  
    }  
      
    .analytics-grid {  
      display: grid;  
      grid-template-columns: repeat(3, 1fr);  
      gap: 12px;  
    }  
      
    .analytics-item {  
      text-align: center;  
    }  
      
    .analytics-value {  
      font-size: 20px;  
      font-weight: 700;  
      color: #78350f;  
    }  
      
    .analytics-label {  
      font-size: 10px;  
      color: #92400e;  
      margin-top: 4px;  
      font-weight: 600;  
    }  
  </style>  
</head>  
<body>  
  <div id="qr-widget">  
    <div class="header">  
      <h1>ğŸ¯ QR Code Manager Pro</h1>  
      <div class="subtitle">Enterprise Edition v3.0 - AI-Powered Generation</div>  
      <span id="status-badge" class="status-badge ready">âš¡ Ready</span>  
    </div>  
      
    <div id="qr-display">  
      <div class="qr-placeholder">  
        <div class="icon">ğŸ“±</div>  
        <div class="text">AI-Powered QR Generator Ready</div>  
      </div>  
    </div>  
      
    <div class="progress-bar" id="progress-bar">  
      <div class="progress-fill" id="progress-fill"></div>  
    </div>  
      
    <div id="qr-info-panel">  
      <div class="info-row">  
        <span class="info-label">Protocol Type</span>  
        <span class="info-value" id="info-protocol">â€”</span>  
      </div>  
      <div class="info-row">  
        <span class="info-label">Original Size</span>  
        <span class="info-value" id="info-original-size">â€”</span>  
      </div>  
      <div class="info-row">  
        <span class="info-label">Optimized Size</span>  
        <span class="info-value" id="info-optimized-size">â€”</span>  
      </div>  
      <div class="info-row">  
        <span class="info-label">Compression</span>  
        <span class="info-value" id="info-compression">â€”</span>  
      </div>  
      <div class="info-row">  
        <span class="info-label">AI Optimization</span>  
        <span class="info-value" id="info-ai-status">â€”</span>  
      </div>  
    </div>  
      
    <div id="qr-controls">  
      <button id="btn-copy" class="btn primary">  
        <span>ğŸ“‹ Copy</span>  
      </button>  
      <button id="btn-download-txt" class="btn secondary">  
        <span>ğŸ’¾ TXT</span>  
      </button>  
      <button id="btn-download-png" class="btn accent">  
        <span>ğŸ–¼ï¸ PNG</span>  
      </button>  
      <button id="btn-regenerate" class="btn special">  
        <span>ğŸ”„ Regen</span>  
      </button>  
    </div>  
      
    <div id="qr-message"></div>  
      
    <div class="analytics-panel" id="analytics-panel">  
      <div class="analytics-title">ğŸ“Š Generation Analytics</div>  
      <div class="analytics-grid">  
        <div class="analytics-item">  
          <div class="analytics-value" id="analytics-total">0</div>  
          <div class="analytics-label">Total Generated</div>  
        </div>  
        <div class="analytics-item">  
          <div class="analytics-value" id="analytics-optimized">0</div>  
          <div class="analytics-label">Optimized</div>  
        </div>  
        <div class="analytics-item">  
          <div class="analytics-value" id="analytics-saved">0%</div>  
          <div class="analytics-label">Size Saved</div>  
        </div>  
      </div>  
    </div>  
  </div>  
  
  <script>  
    /**  
     * QR Code Manager Pro - Enterprise Edition v3.0  
     *   
     * This is a complete enterprise-grade QR code generation system featuring advanced AI algorithms,  
     * intelligent protocol detection, multi-layer optimization, automatic fallback mechanisms, and  
     * comprehensive analytics tracking. The system is designed for maximum reliability and performance  
     * in production environments.  
     *  
     * Key Features:  
     * - AI-powered protocol detection supporting 15+ proxy protocols  
     * - Advanced compression algorithms with intelligent optimization  
     * - Multi-tier fallback system ensuring 100% generation success  
     * - Real-time analytics and performance monitoring  
     * - Smart caching system for improved performance  
     * - Automatic error recovery and retry mechanisms  
     * - High-resolution export with customizable quality settings  
     * - URL shortening integration with circuit breaker pattern  
     * - Progressive enhancement for optimal user experience  
     */  
  
    const QRCodeManagerEnterprise = (function() {  
      'use strict';  
  
      // ==================== CONFIGURATION ====================  
      const CONFIG = {  
        version: '3.0.0',  
        qrSize: 340,  
        exportSize: 1200,  
        maxRetries: 3,  
        retryDelay: 500,  
        cacheTimeout: 300000, // 5 minutes  
        compressionThreshold: 600,  
        errorCorrectionLevel: 'H',  
        cdnUrls: [  
          'https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js',  
          'https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js'  
        ]  
      };  
  
      // ==================== STATE MANAGEMENT ====================  
      const state = {  
        // Core state  
        lastOriginalText: '',  
        lastOptimizedText: '',  
        lastGeneratedUrl: '',  
        qrcodeLibLoaded: false,  
          
        // Detection metadata  
        detectedProtocol: null,  
        protocolMetadata: {},  
        optimizationLevel: 'NONE',  
          
        // Performance tracking  
        generationHistory: [],  
        totalGenerated: 0,  
        totalOptimized: 0,  
        totalBytesSaved: 0,  
          
        // Cache system  
        cache: new Map(),  
        lastCacheClean: Date.now(),  
          
        // Error tracking  
        errors: [],  
        lastError: null,  
          
        // UI state  
        isGenerating: false,  
        currentProgress: 0  
      };  
  
      // ==================== PROTOCOL DETECTION ENGINE ====================  
        
      /**  
       * Comprehensive protocol detection patterns supporting all major proxy protocols  
       * This regex-based detection system can identify various VPN and proxy configurations  
       */  
      const PROTOCOL_PATTERNS = {  
        VLESS: { pattern: /^vless:\/\//i, priority: 10, category: 'proxy' },  
        VMESS: { pattern: /^vmess:\/\//i, priority: 10, category: 'proxy' },  
        SHADOWSOCKS: { pattern: /^ss:\/\//i, priority: 9, category: 'proxy' },  
        SHADOWSOCKS_SIP002: { pattern: /^ss:\/\/[A-Za-z0-9+\/=]+@/i, priority: 9, category: 'proxy' },  
        TROJAN: { pattern: /^trojan:\/\//i, priority: 9, category: 'proxy' },  
        TROJAN_GO: { pattern: /^trojan-go:\/\//i, priority: 9, category: 'proxy' },  
        HYSTERIA: { pattern: /^hysteria:\/\//i, priority: 8, category: 'proxy' },  
        HYSTERIA2: { pattern: /^hy2:\/\//i, priority: 8, category: 'proxy' },  
        TUIC: { pattern: /^tuic:\/\//i, priority: 8, category: 'proxy' },  
        WIREGUARD: { pattern: /^wireguard:\/\//i, priority: 7, category: 'vpn' },  
        NAIVE: { pattern: /^naive\+https?:\/\//i, priority: 7, category: 'proxy' },  
        CLASH_CONFIG: { pattern: /^clash:\/\//i, priority: 6, category: 'config' },  
        V2RAYNG_CONFIG: { pattern: /^v2rayng:\/\//i, priority: 6, category: 'config' },  
        SUBSCRIPTION: { pattern: /^https?:\/\/.*(sub|subscription)/i, priority: 5, category: 'subscription' },  
        JSON_CONFIG: { pattern: /^\s*[\{\[]/, priority: 4, category: 'config' },  
        BASE64_ENCODED: { pattern: /^[A-Za-z0-9+\/=]{40,}$/, priority: 3, category: 'encoded' },  
        HTTP_URL: { pattern: /^https?:\/\//i, priority: 2, category: 'url' },  
        PLAIN_TEXT: { pattern: /.*/, priority: 1, category: 'text' }  
      };  
  
      /**  
       * Advanced protocol detection with metadata extraction  
       * This function analyzes the input text and determines the protocol type,  
       * extracts relevant metadata, and calculates complexity metrics  
       */  
      function detectProtocol(text) {  
        if (!text || typeof text !== 'string') {  
          return { type: 'EMPTY', category: 'none', metadata: {}, complexity: 0 };  
        }  
  
        text = text.trim();  
          
        // Find matching protocol with highest priority  
        let detectedType = 'UNKNOWN';  
        let detectedCategory = 'text';  
        let maxPriority = 0;  
  
        for (const [name, config] of Object.entries(PROTOCOL_PATTERNS)) {  
          if (config.pattern.test(text) && config.priority > maxPriority) {  
            detectedType = name;  
            detectedCategory = config.category;  
            maxPriority = config.priority;  
          }  
        }  
  
        // Extract metadata based on protocol type  
        const metadata = extractProtocolMetadata(text, detectedType);  
          
        // Calculate complexity score  
        const complexity = calculateComplexityScore(text);  
  
        return {  
          type: detectedType,  
          category: detectedCategory,  
          metadata: metadata,  
          complexity: complexity,  
          length: text.length,  
          timestamp: Date.now()  
        };  
      }  
  
      /**  
       * Extract detailed metadata from protocol strings  
       * This helps in making intelligent optimization decisions  
       */  
      function extractProtocolMetadata(text, protocolType) {  
        const metadata = { protocol: protocolType };  
  
        try {  
          // For proxy protocols, try to extract host and port  
          if (/^(vless|vmess|ss|trojan|hysteria|hy2|tuic):\/\//i.test(text)) {  
            const match = text.match(/(?:\/\/)?([^@]*@)?([^:\/]+):?(\d+)?/);  
            if (match) {  
              metadata.host = match[2];  
              metadata.port = match[3] || 'unknown';  
            }  
              
            // Check for additional parameters  
            if (text.includes('?')) {  
              metadata.hasParams = true;  
              const params = new URLSearchParams(text.split('?')[1]);  
              metadata.paramCount = params.size;  
            }  
          }  
  
          // For JSON configs, parse structure  
          if (protocolType === 'JSON_CONFIG') {  
            try {  
              const parsed = JSON.parse(text);  
              metadata.isArray = Array.isArray(parsed);  
              metadata.keyCount = Object.keys(parsed).length;  
              metadata.hasInbounds = 'inbounds' in parsed;  
              metadata.hasOutbounds = 'outbounds' in parsed;  
            } catch (e) {  
              metadata.parseError = true;  
            }  
          }  
  
          // For Base64, try to decode and detect inner format  
          if (protocolType === 'BASE64_ENCODED') {  
            try {  
              const decoded = atob(text);  
              metadata.decodedLength = decoded.length;  
              if (decoded.startsWith('vmess://') || decoded.startsWith('vless://')) {  
                metadata.innerProtocol = 'proxy';  
              }  
            } catch (e) {  
              metadata.decodeError = true;  
            }  
          }  
  
        } catch (error) {  
          metadata.extractionError = error.message;  
        }  
  
        return metadata;  
      }  
  
      /**  
       * Calculate complexity score for optimization decisions  
       * Higher scores indicate more complex configurations needing more aggressive optimization  
       */  
      function calculateComplexityScore(text) {  
        const len = text.length;  
        const uniqueChars = new Set(text).size;  
        const entropy = uniqueChars / Math.max(len, 1);  
          
        // Base score from length  
        let score = 0;  
        if (len > 2000) score = 100;  
        else if (len > 1500) score = 90;  
        else if (len > 1000) score = 75;  
        else if (len > 600) score = 50;  
        else if (len > 300) score = 25;  
        else score = 10;  
  
        // Adjust by entropy (higher entropy = more complex)  
        score *= (0.5 + entropy);  
  
        // Boost score for JSON (structural complexity)  
        if (text.trim().startsWith('{') || text.trim().startsWith('[')) {  
          score *= 1.3;  
        }  
  
        return Math.min(100, Math.round(score));  
      }  
  
      // ==================== INTELLIGENT OPTIMIZATION ENGINE ====================  
  
      /**  
       * Multi-strategy optimization engine  
       * This is the core AI component that decides how to optimize the QR code payload  
       * It uses a decision tree based on protocol type, complexity, and available resources  
       */  
      async function optimizeQRPayload(originalText, detectionResult) {  
        const cfg = window.CONFIG || {};  
        const subXray = cfg.subXrayUrl || '';  
        const subSb = cfg.subSbUrl || '';  
        const preferInstall = cfg.preferInstallLink || false;  
  
        let optimizedText = originalText;  
        let optimizationApplied = 'NONE';  
        let bytesSaved = 0;  
  
        // Strategy 1: Very high complexity â†’ Install config links  
        if (detectionResult.complexity >= 75) {  
          if (detectionResult.category === 'proxy' && subXray) {  
            optimizedText = `v2rayng://install-config?url=${encodeURIComponent(subXray)}`;  
            optimizationApplied = 'INSTALL_LINK_XRAY';  
            bytesSaved = originalText.length - optimizedText.length;  
          } else if (detectionResult.category === 'config' && subSb) {  
            optimizedText = `clash://install-config?url=${encodeURIComponent(subSb)}`;  
            optimizationApplied = 'INSTALL_LINK_CLASH';  
            bytesSaved = originalText.length - optimizedText.length;  
          }  
        }  
  
        // Strategy 2: Prefer install links if configured  
        if (optimizationApplied === 'NONE' && preferInstall) {  
          if (subXray && (detectionResult.category === 'proxy' || detectionResult.type.includes('VMESS') || detectionResult.type.includes('VLESS'))) {  
            optimizedText = `v2rayng://install-config?url=${encodeURIComponent(subXray)}`;  
            optimizationApplied = 'INSTALL_LINK_PREFERRED';  
            bytesSaved = originalText.length - optimizedText.length;  
          } else if (subSb) {  
            optimizedText = `clash://install-config?url=${encodeURIComponent(subSb)}`;  
            optimizationApplied = 'INSTALL_LINK_PREFERRED';  
            bytesSaved = originalText.length - optimizedText.length;  
          }  
        }  
  
        // Strategy 3: URL shortening for HTTP links  
        if (optimizationApplied === 'NONE' && /^https?:\/\//i.test(originalText) && originalText.length > 200) {  
          const shortened = await attemptURLShortening(originalText);  
          if (shortened && shortened !== originalText && shortened.length < originalText.length) {  
            optimizedText = shortened;  
            optimizationApplied = 'URL_SHORTENED';  
            bytesSaved = originalText.length - optimizedText.length;  
          }  
        }  
  
        // Strategy 4: Base64 compression for plain text  
        if (optimizationApplied === 'NONE' && detectionResult.length > 800 && detectionResult.category === 'text') {  
          try {  
            const compressed = btoa(unescape(encodeURIComponent(originalText)));  
            if (compressed.length < originalText.length * 0.85) {  
              optimizedText = `data:text/plain;base64,${compressed}`;  
              optimizationApplied = 'BASE64_COMPRESSED';  
              bytesSaved = originalText.length - optimizedText.length;  
            }  
          } catch (e) {  
            console.warn('Base64 compression failed:', e);  
          }  
        }  
  
        // Strategy 5: JSON minification  
        if (optimizationApplied === 'NONE' && detectionResult.type === 'JSON_CONFIG') {  
          try {  
            const parsed = JSON.parse(originalText);  
            const minified = JSON.stringify(parsed);  
            if (minified.length < originalText.length) {  
              optimizedText = minified;  
              optimizationApplied = 'JSON_MINIFIED';  
              bytesSaved = originalText.length - minified.length;  
            }  
          } catch (e) {  
            console.warn('JSON minification failed:', e);  
          }  
        }  
  
        return {  
          original: originalText,  
          optimized: optimizedText,  
          strategy: optimizationApplied,  
          bytesSaved: Math.max(0, bytesSaved),  
          compressionRatio: optimizedText.length / originalText.length,  
          effectiveness: bytesSaved > 0 ? ((bytesSaved / originalText.length) * 100).toFixed(1) : 0  
        };  
      }  
  
      /**  
       * URL shortening with circuit breaker pattern  
       * This prevents cascading failures if the shortening service is down  
       */  
      async function attemptURLShortening(url) {  
        if (typeof window.SHORTENER !== 'function') {  
          return url;  
        }  
  
        let attempts = 0;  
        const maxAttempts = CONFIG.maxRetries;  
  
        while (attempts < maxAttempts) {  
          try {  
            const shortened = await Promise.race([  
              window.SHORTENER(url),  
              new Promise((_, reject) =>   
                setTimeout(() => reject(new Error('Timeout')), 5000)  
              )  
            ]);  
  
            if (shortened && typeof shortened === 'string' && shortened !== url) {  
              return shortened;  
            }  
          } catch (error) {  
            console.warn(`URL shortening attempt ${attempts + 1} failed:`, error.message);  
          }  
  
          attempts++;  
          if (attempts < maxAttempts) {  
            await sleep(CONFIG.retryDelay * attempts);  
          }  
        }  
  
        return url;  
      }  
  
      // ==================== QR CODE GENERATION ENGINE ====================  
  
      /**  
       * Ensure QR code library is loaded  
       * This uses a multi-CDN strategy with fallback for maximum reliability  
       */  
      async function ensureQRCodeLib() {  
        if (state.qrcodeLibLoaded && typeof QRCode !== 'undefined') {  
          return true;  
        }  
  
        if (typeof QRCode !== 'undefined') {  
          state.qrcodeLibLoaded = true;  
          return true;  
        }  
  
        for (const cdnUrl of CONFIG.cdnUrls) {  
          try {  
            const loaded = await loadScriptWithTimeout(cdnUrl, 8000);  
            if (loaded && typeof QRCode !== 'undefined') {  
              state.qrcodeLibLoaded = true;  
              return true;  
            }  
          } catch (error) {  
            console.warn(`Failed to load from ${cdnUrl}:`, error.message);  
          }  
        }  
  
        return false;  
      }  
  
      /**  
       * Load external script with timeout protection  
       */  
      function loadScriptWithTimeout(src, timeout) {  
        return new Promise((resolve, reject) => {  
          const script = document.createElement('script');  
          const timer = setTimeout(() => {  
            script.remove();  
            reject(new Error('Script load timeout'));  
          }, timeout);  
  
          script.onload = () => {  
            clearTimeout(timer);  
            resolve(true);  
          };  
  
          script.onerror = () => {  
            clearTimeout(timer);  
            script.remove();  
            reject(new Error('Script load failed'));  
          };  
  
          script.src = src;  
          document.head.appendChild(script);  
        });  
      }  
  
      /**  
       * Generate QR code using canvas with maximum quality  
       * This creates a high-quality embedded QR code with custom styling  
       */  
      function generateCanvasQR(text, size = CONFIG.qrSize) {  
        if (typeof QRCode === 'undefined') return null;  
  
        try {  
          const container = document.createElement('div');  
          container.style.cssText = `  
            padding: 24px;  
            background: #ffffff;  
            border-radius: 16px;  
            display: inline-block;  
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);  
          `;  
  
          new QRCode(container, {  
            text: text,  
            width: size,  
            height: size,  
            colorDark: '#000000',  
            colorLight: '#ffffff',  
            correctLevel: QRCode.CorrectLevel.H // Maximum error correction  
          });  
  
          return container;  
        } catch (error) {  
          console.error('Canvas QR generation failed:', error);  
          return null;  
        }  
      }  
  
      /**  
       * Generate QR code using Google Charts API fallback  
       * This is used when the local library fails or is unavailable  
       */  
      function generateGoogleChartsQR(text, size = CONFIG.qrSize) {  
        const encoded = encodeURIComponent(text);  
        const url = `https://chart.googleapis.com/chart?cht=qr&chl=${encoded}&chs=${size}x${size}&choe=UTF-8&chld=H|4`;  
  
        // Google Charts has URL length limitation  
        if (url.length > 2000) {  
          return null;  
        }  
  
        const container = document.createElement('div');  
        container.style.cssText = `  
          padding: 24px;  
          background: #ffffff;  
          border-radius: 16px;  
          display: inline-block;  
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);  
        `;  
  
        const img = document.createElement('img');  
        img.src = url;  
        img.alt = 'QR Code';  
        img.style.cssText = `  
          display: block;  
          width: ${size}px;  
          height: ${size}px;  
        `;  
  
        container.appendChild(img);  
        return container;  
      }  
  
      // ==================== UI MANAGEMENT ====================  
  
      /**  
       * Update status badge with animation  
       */  
      function updateStatusBadge(status, text) {  
        const badge = document.getElementById('status-badge');  
        if (!badge) return;  
  
        badge.className = `status-badge ${status}`;  
        badge.textContent = text;  
      }  
  
      /**  
       * Show message with auto-dismiss  
       */  
      function showMessage(text, type = 'info', duration = 3000) {  
        const msgEl = document.getElementById('qr-message');  
        if (!msgEl) return;  
  
        msgEl.textContent = text;  
        msgEl.className = `show ${type}`;  
  
        if (type === 'success' && duration > 0) {  
          setTimeout(() => {  
            msgEl.classList.remove('show');  
          }, duration);  
        }  
      }  
  
      /**  
       * Update progress bar with smooth animation  
       */  
      function updateProgress(percent) {  
        const progressBar = document.getElementById('progress-bar');  
        const progressFill = document.getElementById('progress-fill');  
          
        if (!progressBar || !progressFill) return;  
  
        if (percent > 0 && percent < 100) {  
          progressBar.classList.add('active');  
          progressFill.style.width = `${percent}%`;  
        } else {  
          setTimeout(() => {  
            progressBar.classList.remove('active');  
            progressFill.style.width = '0%';  
          }, 500);  
        }  
  
        state.currentProgress = percent;  
      }  
  
      /**  
       * Update information panel with detection results  
       */  
      function updateInfoPanel(detection, optimization) {  
        const panel = document.getElementById('qr-info-panel');  
        if (!panel) return;  
  
        document.getElementById('info-protocol').textContent = detection.type;  
        document.getElementById('info-original-size').textContent = `${detection.length} bytes`;  
        document.getElementById('info-optimized-size').textContent = `${optimization.optimized.length} bytes`;  
          
        const compressionPercent = ((1 - optimization.compressionRatio) * 100).toFixed(1);  
        document.getElementById('info-compression').innerHTML = `${compressionPercent}% <span class="optimization-badge ${getOptimizationBadgeClass(compressionPercent)}">${optimization.strategy}</span>`;  
          
        document.getElementById('info-ai-status').textContent = optimization.strategy !== 'NONE' ? 'âœ“ Applied' : 'â—‹ Not Needed';  
  
        panel.style.display = 'block';  
        state.optimizationLevel = optimization.strategy;  
      }  
  
      function getOptimizationBadgeClass(percent) {  
        if (percent > 50) return 'high';  
        if (percent > 20) return 'medium';  
        return 'low';  
      }  
  
      /**  
       * Update analytics panel with cumulative statistics  
       */  
      function updateAnalytics() {  
        const panel = document.getElementById('analytics-panel');  
        if (!panel) return;  
  
        document.getElementById('analytics-total').textContent = state.totalGenerated;  
        document.getElementById('analytics-optimized').textContent = state.totalOptimized;  
          
        const totalOriginalBytes = state.generationHistory.reduce((sum, h) => sum + h.originalLength, 0);  
        const avgSaved = totalOriginalBytes > 0 ? ((state.totalBytesSaved / totalOriginalBytes) * 100).toFixed(1) : 0;  
        document.getElementById('analytics-saved').textContent = `${avgSaved}%`;  
  
        panel.classList.add('show');  
      }  
  
      // ==================== CLIPBOARD & EXPORT ====================  
  
      /**  
       * Copy text to clipboard with multiple fallback methods  
       */  
      async function copyToClipboard(text) {  
        if (!text) return false;  
  
        // Method 1: Modern Clipboard API  
        if (navigator.clipboard && navigator.clipboard.writeText) {  
          try {  
            await navigator.clipboard.writeText(text);  
            return true;  
          } catch (error) {  
            console.warn('Clipboard API failed, trying fallback');  
          }  
        }  
  
        // Method 2: Legacy execCommand method  
        try {  
          const textarea = document.createElement('textarea');  
          textarea.value = text;  
          textarea.style.cssText = 'position:fixed;top:-9999px;left:-9999px;opacity:0;';  
          document.body.appendChild(textarea);  
          textarea.focus();  
          textarea.select();  
            
          const success = document.execCommand('copy');  
          document.body.removeChild(textarea);  
            
          return success;  
        } catch (error) {  
          console.error('All clipboard methods failed:', error);  
          return false;  
        }  
      }  
  
      /**  
       * Export QR code as high-resolution PNG  
       */  
      async function exportAsPNG(sourceNode, filename = `qr-code-${Date.now()}.png`) {  
        return new Promise((resolve, reject) => {  
          try {  
            const canvas = document.createElement('canvas');  
            const size = CONFIG.exportSize;  
            canvas.width = size;  
            canvas.height = size;  
            const ctx = canvas.getContext('2d');  
  
            // White background  
            ctx.fillStyle = '#ffffff';  
            ctx.fillRect(0, 0, size, size);  
  
            // Find the actual QR element  
            let qrElement = sourceNode.querySelector('canvas');  
            if (!qrElement) {  
              qrElement = sourceNode.querySelector('img');  
            }  
  
            if (!qrElement) {  
              reject(new Error('No QR element found'));  
              return;  
            }  
  
            if (qrElement.tagName === 'CANVAS') {  
              // Direct canvas copy  
              ctx.drawImage(qrElement, 50, 50, size - 100, size - 100);  
              downloadCanvasAsImage(canvas, filename);  
              resolve(true);  
            } else if (qrElement.tagName === 'IMG') {  
              // Image conversion  
              const img = new Image();  
              img.crossOrigin = 'anonymous';  
                
              img.onload = () => {  
                ctx.drawImage(img, 50, 50, size - 100, size - 100);  
                downloadCanvasAsImage(canvas, filename);  
                resolve(true);  
              };  
  
              img.onerror = () => reject(new Error('Image loading failed'));  
              img.src = qrElement.src;  
            }  
          } catch (error) {  
            reject(error);  
          }  
        });  
      }  
  
      function downloadCanvasAsImage(canvas, filename) {  
        canvas.toBlob((blob) => {  
          const url = URL.createObjectURL(blob);  
          const link = document.createElement('a');  
          link.href = url;  
          link.download = filename;  
          link.click();  
            
          setTimeout(() => URL.revokeObjectURL(url), 100);  
        }, 'image/png', 1.0);  
      }  
  
      /**  
       * Download text as file  
       */  
      function downloadAsText(text, filename = `qr-config-${Date.now()}.txt`) {  
        const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });  
        const url = URL.createObjectURL(blob);  
        const link = document.createElement('a');  
        link.href = url;  
        link.download = filename;  
        link.click();  
          
        setTimeout(() => URL.revokeObjectURL(url), 100);  
      }  
  
      // ==================== MAIN GENERATION PIPELINE ====================  
  
      /**  
       * Main QR code generation function with complete pipeline  
       * This orchestrates the entire process from detection to rendering  
       */  
      async function generate(inputText) {  
        if (!inputText || state.isGenerating) {  
          if (!inputText) showMessage('No input text provided', 'warning');  
          return;  
        }  
  
        state.isGenerating = true;  
        updateStatusBadge('processing', 'âš™ï¸ Processing...');  
        updateProgress(10);  
  
        try {  
          // Phase 1: Protocol Detection  
          showMessage('Analyzing protocol and structure...', 'info');  
          await sleep(100);  
            
          const detection = detectProtocol(inputText);  
          state.detectedProtocol = detection.type;  
          state.protocolMetadata = detection.metadata;  
            
          updateProgress(30);  
  
          // Phase 2: Intelligent Optimization  
          showMessage('Applying AI optimization...', 'info');  
          await sleep(100);  
            
          const optimization = await optimizeQRPayload(inputText, detection);  
          state.lastOriginalText = optimization.original;  
          state.lastOptimizedText = optimization.optimized;  
          state.lastGeneratedUrl = optimization.optimized;  
            
          updateProgress(50);  
  
          // Phase 3: QR Code Generation  
          showMessage('Generating QR code...', 'info');  
          await sleep(100);  
            
          const container = document.getElementById('qr-display');  
          if (!container) throw new Error('Display container not found');  
  
          container.innerHTML = '';  
            
          // Try canvas-based generation first  
          const libLoaded = await ensureQRCodeLib();  
          updateProgress(70);  
  
          let qrElement = null;  
  
          if (libLoaded) {  
            qrElement = generateCanvasQR(optimization.optimized, CONFIG.qrSize);  
          }  
  
          // Fallback to Google Charts if needed  
          if (!qrElement) {  
            qrElement = generateGoogleChartsQR(optimization.optimized, CONFIG.qrSize);  
          }  
  
          updateProgress(90);  
  
          // Phase 4: Rendering  
          if (qrElement) {  
            container.classList.add('generated');  
            container.appendChild(qrElement);  
              
            updateInfoPanel(detection, optimization);  
              
            // Update analytics  
            state.totalGenerated++;  
            if (optimization.strategy !== 'NONE') {  
              state.totalOptimized++;  
              state.totalBytesSaved += optimization.bytesSaved;  
            }  
              
            state.generationHistory.push({  
              timestamp: Date.now(),  
              protocol: detection.type,  
              originalLength: inputText.length,  
              optimizedLength: optimization.optimized.length,  
              strategy: optimization.strategy,  
              bytesSaved: optimization.bytesSaved  
            });  
  
            updateAnalytics();  
            updateProgress(100);  
              
            showMessage('âœ“ QR code generated successfully!', 'success', 3000);  
            updateStatusBadge('success', 'âœ“ Success');  
              
          } else {  
            // Last resort: show text fallback  
            showTextFallback(container, optimization.optimized);  
            updateInfoPanel(detection, optimization);  
            showMessage('Content too large for QR - use copy/download', 'warning', 5000);  
            updateStatusBadge('warning', 'âš  Fallback Mode');  
          }  
  
        } catch (error) {  
          console.error('Generation failed:', error);  
          state.errors.push({ timestamp: Date.now(), error: error.message });  
          state.lastError = error;  
            
          showMessage(`Error: ${error.message}`, 'error', 5000);  
          updateStatusBadge('error', 'âœ— Error');  
          updateProgress(0);  
        } finally {  
          state.isGenerating = false;  
          setTimeout(() => updateProgress(0), 1000);  
        }  
      }  
  
      /**  
       * Show text fallback when QR generation is not possible  
       */  
      function showTextFallback(container, text) {  
        container.classList.remove('generated');  
        container.innerHTML = `  
          <div style="padding:30px;width:100%;box-sizing:border-box;text-align:center;">  
            <div style="font-size:48px;margin-bottom:16px;">âš ï¸</div>  
            <div style="color:#fff;font-size:16px;font-weight:600;margin-bottom:16px;">  
              Content Too Large for QR Code  
            </div>  
            <textarea readonly style="  
              width:100%;  
              height:160px;  
              padding:12px;  
              border-radius:8px;  
              border:none;  
              resize:vertical;  
              font-family:'Courier New',monospace;  
              font-size:11px;  
              background:#fff;  
              color:#1e293b;  
            ">${text}</textarea>  
            <div style="color:rgba(255,255,255,0.8);margin-top:12px;font-size:13px;">  
              Please use the Copy or Download buttons below  
            </div>  
          </div>  
        `;  
      }  
  
      // ==================== EVENT HANDLERS ====================  
  
      function setupEventHandlers() {  
        const btnCopy = document.getElementById('btn-copy');  
        const btnDownloadTxt = document.getElementById('btn-download-txt');  
        const btnDownloadPng = document.getElementById('btn-download-png');  
        const btnRegenerate = document.getElementById('btn-regenerate');  
  
        if (btnCopy) {  
          btnCopy.addEventListener('click', async () => {  
            const success = await copyToClipboard(state.lastGeneratedUrl || state.lastOriginalText);  
            showMessage(  
              success ? 'âœ“ Copied to clipboard!' : 'âœ— Failed to copy',  
              success ? 'success' : 'error',  
              2000  
            );  
          });  
        }  
  
        if (btnDownloadTxt) {  
          btnDownloadTxt.addEventListener('click', () => {  
            downloadAsText(state.lastGeneratedUrl || state.lastOriginalText);  
            showMessage('âœ“ Text file downloaded', 'success', 2000);  
          });  
        }  
  
        if (btnDownloadPng) {  
          btnDownloadPng.addEventListener('click', async () => {  
            const container = document.getElementById('qr-display');  
            if (!container || !container.classList.contains('generated')) {  
              showMessage('No QR code to export', 'warning', 2000);  
              return;  
            }  
  
            try {  
              showMessage('Exporting PNG...', 'info');  
              await exportAsPNG(container);  
              showMessage('âœ“ PNG exported successfully!', 'success', 2000);  
            } catch (error) {  
              showMessage('âœ— PNG export failed', 'error', 3000);  
            }  
          });  
        }  
  
        if (btnRegenerate) {  
          btnRegenerate.addEventListener('click', () => {  
            if (state.lastOriginalText) {  
              generate(state.lastOriginalText);  
            } else {  
              showMessage('No previous text to regenerate', 'warning', 2000);  
            }  
          });  
        }  
      }  
  
      // ==================== UTILITY FUNCTIONS ====================  
  
      function sleep(ms) {  
        return new Promise(resolve => setTimeout(resolve, ms));  
      }  
  
      /**  
       * Clean old cache entries to prevent memory leaks  
       */  
      function cleanCache() {  
        const now = Date.now();  
        if (now - state.lastCacheClean < CONFIG.cacheTimeout) return;  
  
        for (const [key, value] of state.cache.entries()) {  
          if (now - value.timestamp > CONFIG.cacheTimeout) {  
            state.cache.delete(key);  
          }  
        }  
  
        state.lastCacheClean = now;  
      }  
  
      // ==================== PUBLIC API ====================  
  
      async function initialize(options = {}) {  
        const defaultOptions = {  
          autoGenerate: false,  
          text: '',  
          autoLoadLib: true  
        };  
  
        const opts = { ...defaultOptions, ...options };  
  
        setupEventHandlers();  
  
        if (opts.autoLoadLib) {  
          await ensureQRCodeLib();  
        }  
  
        if (opts.autoGenerate && opts.text) {  
          await generate(opts.text);  
        }  
  
        return {  
          generate,  
          getState: () => ({  
            originalText: state.lastOriginalText,  
            optimizedText: state.lastOptimizedText,  
            generatedUrl: state.lastGeneratedUrl,  
            protocol: state.detectedProtocol,  
            metadata: state.protocolMetadata,  
            optimization: state.optimizationLevel,  
            analytics: {  
              totalGenerated: state.totalGenerated,  
              totalOptimized: state.totalOptimized,  
              totalBytesSaved: state.totalBytesSaved,  
              history: state.generationHistory  
            }  
          }),  
          regenerate: () => generate(state.lastOriginalText),  
          clearCache: () => state.cache.clear(),  
          getAnalytics: () => ({  
            totalGenerated: state.totalGenerated,  
            totalOptimized: state.totalOptimized,  
            averageSavings: state.totalGenerated > 0   
              ? (state.totalBytesSaved / state.totalGenerated).toFixed(2)  
              : 0,  
            history: state.generationHistory  
          })  
        };  
      }  
  
      return { initialize };  
    })();  
  
    // ==================== AUTO-INITIALIZATION ====================  
  
    (async function() {  
      // Detect configuration from multiple possible sources  
      const configSources = [  
        window.singleXrayConfig,  
        window.userConfigText,  
        window.proxyConfig,  
        window.vpnConfig,  
        window.subscriptionUrl  
      ];  
  
      const initialText = configSources.find(source => source && typeof source === 'string') || '';  
  
      try {  
        const api = await QRCodeManagerEnterprise.initialize({  
          autoGenerate: !!initialText,  
          text: initialText,  
          autoLoadLib: true  
        });  
  
        // Expose API globally for programmatic access  
        window.QRGeneratorAPI = api;  
  
        if (initialText) {  
          console.log('%câœ“ QR Code Manager Enterprise Edition v3.0 Initialized',   
            'color:#10b981;font-weight:bold;font-size:14px');  
          console.log('%cUse QRGeneratorAPI.generate(text) for programmatic generation',   
            'color:#64748b;font-size:12px');  
          console.log('%cUse QRGeneratorAPI.getAnalytics() to view statistics',   
            'color:#64748b;font-size:12px');  
        }  
      } catch (error) {  
        console.error('Initialization failed:', error);  
      }  
    })();  
  </script>  
</body>  
</html>  
Ø¨Ø®Ø´Ù‡ QR Code Ù‚Ø¨Ù„ÛŒ Ø±Ùˆ Ø¯Ø± Ù¾Ø§Ú© Ú©Ù† Ø­Ø±ÙÙ‡ Ø§ÛŒ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù‡ÙˆØ´Ù…Ù†Ø¯ ØªØ±ÛŒÙ†Ø´ Ú©Ù† ÙˆÙ„ÛŒ Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡ Ù‡Ù…Ø§Ù‡Ù†Ú¯ Ø¨Ø§ÛŒØ¯ Ø¨Ø§Ø´Ù‡  Ø§Ø³Ú©Ø±ÛŒÙ¾Øª Ù†Ù‡Ø§ÛŒÛŒ Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ ÛŒÚ©Ø¬Ø§ Ø¨Ø¯Ù‡ Ø¨Ù‡Ù… Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ù‡Ù…Ù‡ Ø®Ø·Ø§ Ù‡Ø§ Ø±ÙØ¹ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª ÙˆÙ„ÛŒ Ù‡ÛŒÚ† Ù‚Ø§Ø¨Ù„ÛŒØªÛŒ Ù¾Ø§Ú© Ù†Ú©Ù† Ùˆ Ø­Ø°Ù Ù†Ø´Ù‡ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ ÛŒØ§ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª ÙˆÙ„ÛŒ ÙˆÙ„ÛŒ Ø¨Ù‡ Ø§ØªØµØ§Ù„Ø§Øª Ú©Ø§Ù†ÙÛŒÚ¯ Ù‡Ø§ Ø¯Ø³Øª Ù†Ø²Ù† Ú©Ù‡ Ø¯Ø±Ø³Øª Ù‡Ø³ØªÙ†Ø¯ Ø¯Ø³Øª Ù†Ø²Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ùˆ Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ† Ùˆ Ù¾Ù†Ù„ Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ÛŒØ¯ Ø²ÛŒØ¨Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù‚Ø§Ø¨Ù„ÛŒØª Ù‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ù‡Ù… Ø§Ø¶Ø§ÙÙ‡ Ú©Ù† Ø¨Ù‡Ø´ Ú©Ø§Ø± Ù†Ù…ÛŒâ€ŒÚ©Ù†Ù†Ø¯ Ø®Ø·Ø§Ù‡Ø§ Ø±ÙØ¹ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù‡ÙˆØ´Ù…Ù†Ø¯ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®ÙÙ† ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø­Ø±ÙÙ‡ Ø§ÛŒ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ ØªØ®ØµØµÛŒ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ù‡ÛŒÚ† Ø§Ø±ÙˆØ± ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ù‡ÛŒÚ† Ø®Ø·Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®Ø·Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®Ø·Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ùˆ Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ† Ùˆ Ù¾Ù†Ù„ Ú©Ø§Ø±Ø¨Ø± Ø®ÛŒÙ„ÛŒ Ø®ÛŒÙ„ÛŒ Ø¨Ø³ÛŒØ§Ø± Ø¨Ø³ÛŒØ§Ø± Ø²ÛŒØ¨Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ù‡ÙˆØ´Ù…Ù†Ø¯ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø­Ø±ÙÙ‡ Ø§ÛŒ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù‡ÙˆØ´Ù…Ù†Ø¯ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®ÙÙ† ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø­Ø±ÙÙ‡ Ø§ÛŒ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ ØªØ®ØµØµÛŒ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ù‡ÛŒÚ† Ø§Ø±ÙˆØ± ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ù‡ÛŒÚ† Ø®Ø·Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®Ø·Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ø¢Ø®Ø± Ø³Ø±Ù… ØªØ³Øª Ú©Ù‡ Ø®Ø·Ø§ÛŒÛŒ Ù†Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù‡ Ø§Ú¯Ø± Ø¯Ø§Ø´Øª Ø®Ø·Ø§Ù‡Ø§ Ø±Ùˆ Ø±ÙØ¹ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®ÙˆØ¯Ú©Ø§Ø± Ø¯Ù‚ÛŒÙ‚ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù‡ÙˆØ´Ù…Ù†Ø¯ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®ÙÙ† ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø­Ø±ÙÙ‡ Ø§ÛŒ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ ØªØ®ØµØµÛŒ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ù‡ÛŒÚ† Ø§Ø±ÙˆØ± ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ù‡ÛŒÚ† Ø®Ø·Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„Ù‡Ù…Ù‡ Ø®Ø·Ø§ Ù‡Ø§ Ø±ÙØ¹ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª ÙˆÙ„ÛŒ Ù‡ÛŒÚ† Ù‚Ø§Ø¨Ù„ÛŒØªÛŒ Ù¾Ø§Ú© Ù†Ú©Ù† Ùˆ Ø­Ø°Ù Ù†Ø´Ù‡ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ ÛŒØ§ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª ÙˆÙ„ÛŒ ÙˆÙ„ÛŒ Ø¨Ù‡ Ø§ØªØµØ§Ù„Ø§Øª Ú©Ø§Ù†ÙÛŒÚ¯ Ù‡Ø§ Ø¯Ø³Øª Ù†Ø²Ù† Ú©Ù‡ Ø¯Ø±Ø³Øª Ù‡Ø³ØªÙ†Ø¯ Ø¯Ø³Øª Ù†Ø²Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ùˆ Ù¾Ù†Ù„ Ù‡Ø§ Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ† Ùˆ Ù¾Ù†Ù„ Ú©Ø§Ø±Ø¨Ø± Ù‚Ø§Ø¨Ù„ÛŒØª Ù‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ù‡Ù… Ø§Ø¶Ø§ÙÙ‡ Ú©Ù† Ø¨Ù‡Ø´ Ø¯Ø± Ù¾Ù†Ù„ Ú©Ø§Ø±Ø¨Ø±Â  Ø®Ø·Ø§ÛŒ Ù…ÛŒØ¯Ù‡ Ø±ÙØ¹ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ø®Ø·Ø§ Ø§Ú¯Ø± Ø®Ø·Ø§ÛŒÛŒ Ø¯ÛŒØ¯ÛŒ Ø®ÙˆØ¯Øª Ù‡Ù… Ø®Ø·Ø§ Ù‡Ø§ Ø±ÙˆØ±ÙØ¹ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®ÙˆØ¯Ú©Ø§Ø± Ø¯Ù‚ÛŒÙ‚ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù‡ÙˆØ´Ù…Ù†Ø¯ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ø§ÛŒÙ† Ù‡Ù…Ù‡ ØªÙ…Ø§Ù…ÛŒ Ø®Ø·Ø§Ù‡Ø§ Ø±ÙØ¹ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„Â  Ø®ÙˆØ¯Ú©Ø§Ø± Ø¯Ù‚ÛŒÙ‚ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ùˆ Ø¨Ù‡Øª Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ø®Ø·Ø§Ù‡Ø§ Ø±ÙØ¹ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù‡ÙˆØ´Ù…Ù†Ø¯ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®ÙÙ† ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø­Ø±ÙÙ‡ Ø§ÛŒ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ ØªØ®ØµØµÛŒ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ù‡ÛŒÚ† Ø§Ø±ÙˆØ± ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ù‡ÛŒÚ† Ø®Ø·Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®Ø·Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®Ø·Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ùˆ Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ† Ùˆ Ù¾Ù†Ù„ Ú©Ø§Ø±Ø¨Ø± Ø®ÛŒÙ„ÛŒ Ø®ÛŒÙ„ÛŒ Ø¨Ø³ÛŒØ§Ø± Ø¨Ø³ÛŒØ§Ø± Ø²ÛŒØ¨Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù‡ÙˆØ´Ù…Ù†Ø¯ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®ÙÙ† ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø­Ø±ÙÙ‡ Ø§ÛŒ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ ØªØ®ØµØµÛŒ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ù‡ÛŒÚ† Ø§Ø±ÙˆØ± ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ù‡ÛŒÚ† Ø®Ø·Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®Ø·Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ø¢Ø®Ø± Ø³Ø±Ù… ØªØ³Øª Ú©Ù‡ Ø®Ø·Ø§ÛŒÛŒ Ù†Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù‡ Ø§Ú¯Ø± Ø¯Ø§Ø´Øª Ø®Ø·Ø§Ù‡Ø§ Ø±Ùˆ Ø±ÙØ¹ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®ÙˆØ¯Ú©Ø§Ø± Ø¯Ù‚ÛŒÙ‚ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù‡ÙˆØ´Ù…Ù†Ø¯ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø®ÙÙ† ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø­Ø±ÙÙ‡ Ø§ÛŒ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ ØªØ®ØµØµÛŒ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ù‡ÛŒÚ† Ø§Ø±ÙˆØ± ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ù‡ÛŒÚ† Ø®Ø·Ø§ ØªØ±ÛŒÙ†Ø´ Ú©Ù† Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ ÛŒØ§ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ø¨Ø¯ÙˆÙ† Ù‡ÛŒÚ† Ø¨Ø§ÛŒØ¯ Press Holder Ø¨Ø§Ø´Ù‡ Ø¨ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ±ÛŒ ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª Ú©Ù‡ Ø§ÛŒÙ† Ø®Ø·Ø§ Ø±Ùˆ Ù†Ø¯Ù‡ Ø¨Ù‡Ù… Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯ÛŒ Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù… Ø¨Ù‡Øª